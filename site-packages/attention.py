import os
import time

from tqdm import tqdm
import pandas as pd
import numpy as np
import matplotlib
from matplotlib import pyplot as plt
import torch
from torch import optim, nn
import torch.nn.functional as F
from torch.utils.data import Dataset, Subset, DataLoader
from torchvision.utils import make_grid
from torchvision import datasets, transforms
from torchvision.models.resnet import ResNet, BasicBlock
from tensorboardX import SummaryWriter

from endaaman.ml import BaseMLCLI, BaseTrainer, BaseTrainerConfig


class AttentionDataset(Dataset):
    def __init__(self, total, count, loc_0, loc_1, scale):
        self.total = total
        self.count = count
        self.data = np.stack([
            np.random.normal(loc=loc_0, scale=scale, size=total*count//2),
            np.random.normal(loc=loc_1, scale=scale, size=total*count//2),
        ])
        print(self.data.shape)

    def __len__(self):
        return self.total

    def __getitem__(self, idx):
        y = idx % 2
        i = idx // 2

        x = self.data[y, i*self.count : (i+1)*self.count]
        x = torch.from_numpy(x.astype(np.float32))
        y = torch.tensor(y).float()
        return x, y


class AttentionModel(nn.Module):
    def __init__(self, num_features=3, num_classes=1, params_count=100):
        super().__init__()
        self.u = nn.Parameter(torch.randn(params_count, num_features))
        self.v = nn.Parameter(torch.randn(params_count, num_features))
        self.w = nn.Parameter(torch.randn(params_count, 1))

        self.fc = nn.Linear(num_features, num_classes)

    def compute_attention_scores(self, x):
        '''
        Args:
            x (Tensor): (C, ) logits by instance
        Returns:
            Tensor: (1, )
        '''
        # x: (i, ) u: (p, i, ) v: (p, i, )
        xu = torch.tanh(torch.matmul(self.u, x))
        xv = torch.sigmoid(torch.matmul(self.v, x))
        # xu: (p, ) xu: (p, )
        x = xu * xv
        # x: (p, ) w: (p, i, )
        alpha = torch.matmul(x, self.w)
        return alpha

    def forward_attentions(self, features):
        '''
        Args:
            features (Tensor): (B, C) batched features
        Returns:
            Tensor: attention P-values (B, ) [0, 1]
        '''
        attentions = []
        for pred in features:
            attentions.append(self.compute_attention_scores(pred))
        attentions = torch.stack(attentions)
        attentions = torch.softmax(attentions.flatten(), dim=0)
        return attentions

    def forward(self, x, activate=False):
        attentions = self.forward_attentions(x)
        x = torch.matmul(attentions, x)
        x = self.fc(x)
        if activate:
            x = torch.sigmoid(x)
        return x




class TrainerConfig(BaseTrainerConfig):
    batch_size:int = 4
    num_workers:int = 1
    lr: float = 0.001
    num_features: int

    # ds
    total=1000,
    count=40,
    loc_0=1.0,
    loc_1=2.0,
    scale=1.0,

    # model
    params_count: int = 10


class Trainer(BaseTrainer):
    def prepare(self):
        model = AttentionModel(num_features=3, params_count=10)
        self.criterion = nn.BCELoss()
        return model

    def eval(self, inputs, gts):
        self.model.to(self.device)
        preds = self.model(inputs.to(self.device), activate=True)
        gts = torch.mean(gts)
        gts = gts.to(self.device)[None]
        loss = self.criterion(preds, gts)
        return loss, preds[None]


class CLI(BaseMLCLI):
    class TrainArgs(BaseMLCLI.CommonArgs):
        count: int = 3
        epoch: int = 50

    def run_train(self, a:TrainArgs):
        ds = AttentionDataset(
            total=1000,
            count=a.count,
            loc_0=1.0,
            loc_1=2.0,
            scale=1.0
        )

        config = TrainerConfig(
            num_features=a.count,
        )

        trainer = Trainer(
            config=config,
            out_dir='out/models/attention',
            train_dataset=ds,
            val_dataset=None,
        )

        trainer.start(a.epoch)

    def run_model(self, a):
        model = AttentionModel(num_features=3, params_count=10)
        x = torch.randn(10, 3)
        y = model(x)

if __name__ == '__main__':
    cli = CLI()
    cli.run()
