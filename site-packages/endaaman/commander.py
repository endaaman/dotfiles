import sys
import argparse
import os
import re
from logging import getLogger
import time
from sys import exit
from collections import OrderedDict
from unittest.mock import patch

from .utils import log

logger = getLogger(__name__)

class Commander():
    def try_exec(self, name, args, warn=True):
        f = getattr(self, name, None)
        if not f:
            if warn:
                raise Exception(f'{name} is not defined')
            return False, None

        if not callable(f):
            raise Exception(f'{name} is not callable')
        return True, f(*args)

    def __init__(self, defaults=None):
        self.defaults = defaults or {}
        self._parser = argparse.ArgumentParser(add_help=False)
        self._common_parser = argparse.ArgumentParser(add_help=False)
        self._arg_common(self._common_parser)
        self.additional_info = OrderedDict()
        subparsers = self._parser.add_subparsers()

        functions = [k[4:] for k in dir(self) if re.match(r'^run_.+', k)]
        for function in functions:
            function_as_param = re.sub('_', '-', function) # "_" -> "-"
            subparser = subparsers.add_parser(function_as_param, parents=[self._common_parser])
            arg_func_name = 'arg_' + function
            self.try_exec(arg_func_name, [subparser], warn=False)
            subparser.set_defaults(function=function)

    def _arg_common(self, parser):
        self.try_exec('arg_common', [parser], warn=False)

    def _pre_common(self):
        self.try_exec('pre_common', [], warn=False)

    def run_i(self):
        # for interupt
        pass

    def run(self):
        self.args = self._parser.parse_args()
        if not hasattr(self.args, 'function'):
            self._parser.print_help()
            exit(0)
        function_as_param = self.args.function

        self._pre_common()
        function = re.sub('-', '_', function_as_param) # "-" -> "_"
        self.try_exec(f'pre_{function}', [], warn=False)

        func_name = f'run_{function}'
        log(f'Starting {func_name}()')
        args_names = vars(self.args).keys()
        if len(args_names) == 0:
            log('\t(no args provided)')
        else:
            maxlen = max([len(k) for k in args_names])
            items = [
                *self.additional_info.items(),
                *vars(self.args).items()
            ]
            for k, v in items:
                log(f'\t{k.ljust(maxlen)} : {v}')

        self.try_exec(func_name, [], warn=True)
        log('Done.')

    def exec(self, params=None):
        params = params or []
        with patch('sys.argv', ['run'] + params):
            self.run()
