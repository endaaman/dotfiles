import torch
import numpy as np
from sklearn import metrics


class MetricsFn:
    def __init__(self, fmt='{:.3f}', threshold=0.5, use_mean=False, group=None):
        self.fmt = fmt
        self.threshold = threshold
        self.use_mean = use_mean
        self.group = group

    def __call__(self, preds, gts):
        raise RuntimeError('Not implemented')

    def format(self, v):
        return self.fmt.format(v)


class BinaryAccuracy(MetricsFn):
    def __call__(self, preds, gts):
        pred_y = preds.cpu().flatten() > self.threshold
        gts_y = gts.cpu().flatten() > self.threshold
        correct = torch.sum(gts_y == pred_y)
        return correct / len(gts_y)

class BinaryRecall(MetricsFn):
    def __call__(self, preds, gts):
        pred_y = preds.cpu().flatten() > self.threshold
        gts_y = gts.cpu().flatten() > self.threshold
        pos_gts_y = gts_y[gts_y > 0]
        if len(pos_gts_y) == 0:
            return -0.0
        return torch.sum(pred_y[gts_y > 0] == pos_gts_y) / len(pos_gts_y)

class BinarySpecificity(MetricsFn):
    def __call__(self, preds, gts):
        pred_y = preds.cpu().flatten() > self.threshold
        gts_y = gts.cpu().flatten() > self.threshold
        neg_gts_y = gts_y[gts_y < 1]
        if len(neg_gts_y) == 0:
            return -0.0
        return torch.sum(pred_y[gts_y < 1] == neg_gts_y) / len(neg_gts_y)

class BinaryAUC(MetricsFn):
    def __call__(self, preds, gts):
        pred_y = preds.cpu().flatten().numpy()
        gts_y = gts.cpu().flatten().numpy()
        return metrics.roc_auc_score(gts_y, pred_y)

class MultiAccuracy(MetricsFn):
    def __init__(self, by_index=True, **kwargs):
        super().__init__(**kwargs)
        self.by_index = by_index

    def __call__(self, preds, gts):
        pred_y = preds.cpu()
        pred_label = np.argmax(pred_y, axis=1)
        if self.by_index:
            gts_label = gts.cpu()
        else:
            gts_label = torch.argmax(gts.cpu(), axis=1)
        correct = torch.sum(gts_label == pred_label)
        return correct / len(gts_label)

class AccuracyByChannel(MetricsFn):
    def __init__(self, target_channel, by_index=True, **kwargs):
        super().__init__(**kwargs)
        self.target_channel = target_channel
        self.by_index = by_index

    def __call__(self, preds, gts):
        target_idx = gts == self.target_channel
        preds = preds[target_idx]
        gts = gts[target_idx]
        if len(gts) == 0:
            return 0.0
        preds_label = np.argmax(preds, axis=1)
        if self.by_index:
            gts_label = gts.cpu()
        else:
            gts_label = torch.argmax(gts.cpu(), axis=1)
        correct = torch.sum(gts_label == preds_label)
        return correct / len(gts_label)
