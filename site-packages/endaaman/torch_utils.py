import random

import torch
import numpy as np
from torch import optim
from torchvision import transforms


def pil_to_tensor(img):
    return transforms.functional.to_tensor(img)

def tensor_to_pil(tensor):
    a = tensor.min()
    b = tensor.max()
    img = (tensor - a) / (b - a)
    return transforms.functional.to_pil_image(img)

def calc_mean_and_std(images, dim=()):
    mean = None
    std = None
    to_tensor = transforms.ToTensor()
    for img in images:
        x = to_tensor(img)
        m, s = x.mean(dim=dim), x.std(dim=dim)
        mean = m if isinstance(m, type(None)) else mean + m
        std = s if isinstance(s, type(None)) else std + s
    mean /= len(images)
    std /= len(images)
    return mean, std


def get_random_states():
    b = {
        'random': random.getstate(),
        'np_random': np.random.get_state(),
        'torch': torch.get_rng_state(),
        'torch_random': torch.random.get_rng_state(),
    }
    if torch.cuda.is_available():
        b.update({
            'cuda_random': torch.cuda.get_rng_state(),
            'cuda_random_all': torch.cuda.get_rng_state_all(),
        })
    return b

def restore_random_states(checkpoint):
    random.setstate(checkpoint['random'])
    np.random.set_state(checkpoint['np_random'])
    torch.set_rng_state(checkpoint['torch'])
    torch.random.set_rng_state(checkpoint['torch_random'])
    if torch.cuda.is_available():
        torch.cuda.set_rng_state(checkpoint['cuda_random'])
        torch.cuda.set_rng_state_all(checkpoint['cuda_random_all'])


def get_state_dict(model):
    if isinstance(model, torch.nn.DataParallel):
        return model.module.state_dict()
    return model.state_dict()
