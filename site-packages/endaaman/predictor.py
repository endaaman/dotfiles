import os
import re
import math
import random
import subprocess
from abc import ABCMeta, abstractmethod
from typing import NamedTuple
from collections import OrderedDict
from datetime import datetime

import numpy as np
import matplotlib
from matplotlib import ticker, pyplot as plt
import torch
from torch import optim
from torch.optim.lr_scheduler import LambdaLR
from torch.utils.data import DataLoader
from torch.utils.tensorboard import SummaryWriter
from tqdm import tqdm


class Predictor(metaclass=ABCMeta):
    def __init__(self, checkpoint, batch_size, device='cpu', **kwargs):
        self.checkpoint = checkpoint
        self.device = device
        self.batch_size = batch_size

        self.model = self.prepare(**kwargs)

    def get_out_dir(self):
        return os.path.join('out', self.checkpoint.trainer_name)

    @abstractmethod
    def prepare(self, **kwargs):
        pass

    def eval(self, inputs):
        return self.model(inputs.to(self.device))

    def collate(self, pred, idx):
        return pred

    def transform_image(self, image):
        raise RuntimeError('NEED OVERRIDE')

    def unpack(self, pack):
        inputs, __labels = pack
        return inputs

    def predict_loader(self, loader):
        preds = []
        idx = 0
        for pack in tqdm(loader, leave=False):
            inputs = self.unpack(pack)
            with torch.no_grad():
                oo = self.eval(inputs)
                for o in oo:
                    preds.append(self.collate(o, idx))
                    idx += 1

        return preds

    def predict(self, images, batch_size=None):
        preds = []
        start = 0
        idx = 0
        batch_size = batch_size or self.batch_size
        t = tqdm(range(0, len(images), batch_size), leave=False)
        for start in t:
            batch = images[start:start+batch_size]
            inputs = torch.stack([self.transform_image(i) for i in batch]).to(self.device)
            with torch.no_grad():
                oo = self.eval(inputs)
                for o in oo:
                    preds.append(self.collate(o, idx))
                    idx += 1

            t.set_description(f'{start} ~ {start + batch_size} / {len(images)}')
            t.refresh()

        return preds
