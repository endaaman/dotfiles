import os
import itertools
from glob import glob

from PIL import Image



def select_side(W, w, idx=None):
    count = int(np.ceil(W / w))
    if count <= 1:
        return 0
    overwrap = (w * count - W) / (count - 1)
    if idx is None:
        idx = np.random.randint(0, count)
    return int(idx * w - overwrap * idx)

def grid_split_with_overwrap(img, size, flattern=False):
    hor_count = int(np.ceil(img.width / size))
    ver_count = int(np.ceil(img.height / size))
    iii = []
    for v_idx in range(ver_count):
        ii = []
        for h_idx in range(hor_count):
            x = select_side(img.width, size, h_idx)
            y = select_side(img.height, size, v_idx)
            ii.append(img.crop((x, y, x+size, y+size)))
        iii.append(ii)

    if flattern:
        iii = list(itertools.chain.from_iterable(iii))
    return iii

def n_split(x, n):
    return [(x + i) // n for i in range(n)]

def grid_split_by_size(img, size, flattern=False):
    hor_sizes = n_split(img.width, max(img.width//size, 1))
    ver_sizes = n_split(img.height, max(img.height//size, 1))
    iii = []
    y = 0

    for ver_size in ver_sizes:
        ii = []
        x = 0
        for hor_size in hor_sizes:
            ii.append(img.crop((x, y, x+hor_size, y+ver_size)))
            x += hor_size
        y += ver_size
        iii.append(ii)

    if flattern:
        iii = list(itertools.chain.from_iterable(iii))
    return iii


def grid_split(img, size, overwrap=True, flattern=False):
    if overwrap:
        return grid_split_with_overwrap(img, size, flattern)
    return grid_split_by_size(img, size, flattern)


def grid_arrange(ggg, col_count=-1):
    if col_count > 0:
        # re-arrange into 2d-list
        pass

    row_count = len(ggg)
    col_count = len(ggg[0])
    for y, gg in enumerate(ggg):
        row_image_list = []
        for x, g in enumerate(gg):
            row_image_list.append(np.array(d))
        h = cv2.hconcat(row_image_list)
        row_images.append(h)
    merged_image = Image.fromarray(cv2.vconcat(row_images))
    return merged_image



def paste_center(bg, fg, overwrite=False):
    # assert bg.width >= fg.width
    # assert bg.height >= fg.height
    x = (bg.width - fg.width) // 2
    y = (bg.height - fg.height) // 2
    if not overwrite:
        bg = bg.copy()
    bg.paste(fg, (x, y))
    return bg


def pad_to_size(img, size=None, color=None):
    if size:
        if hasattr(size, '__len__'):
            assert len(size) == 2
        else:
            size = (size, size)
    else:
        long_side = max(img.size)
        size = (long_side, long_side)

    if img.width/img.height > size[0]/size[1]:
        # 横長
        scale = size[0]/img.width
    else:
        # 縦長
        scale = size[1]/img.height

    fg = img.resize((int(img.width*scale), int(img.height*scale)))
    bg = Image.new(mode=img.mode, size=size, color=color or 0)
    return paste_center(bg, fg)


def load_images_from_dir_or_file(src, with_path=False, with_image=True):
    paths = []
    if os.path.isdir(src):
        paths = glob(os.path.join(src, '*.jpg')) + glob(os.path.join(src, '*.png'))
    elif os.path.isfile(src):
        paths = [src]
    if len(paths) == 0:
        raise RuntimeError(f'Invalid src: {src}')

    if with_image:
        images = [Image.open(p) for p in paths]

    if with_path:
        if with_image:
            return images, paths
        else:
            return paths
    if not with_image:
        raise RuntimeError('Either with_path or with_image should be True.')
    return images
