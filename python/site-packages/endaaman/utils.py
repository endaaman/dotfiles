import os
import numpy as np
from glob import glob
import itertools

from PIL import Image


def select_side(W, w, idx=None):
    count = int(np.ceil(W / w))
    if count <= 1:
        return 0
    overwrap = (w * count - W) / (count - 1)
    if idx is None:
        idx = np.random.randint(0, count)
    return int(idx * w - overwrap * idx)

def grid_split_with_overwrap(img, size, flattern=False):
    hor_count = int(np.ceil(img.width / size))
    ver_count = int(np.ceil(img.height / size))
    iii = []
    for v_idx in range(ver_count):
        ii = []
        for h_idx in range(hor_count):
            x = select_side(img.width, size, h_idx)
            y = select_side(img.height, size, v_idx)
            ii.append(img.crop((x, y, x+size, y+size)))
        iii.append(ii)

    if flattern:
        iii = list(itertools.chain.from_iterable(iii))
    return iii

def n_split(x, n):
    return [(x + i) // n for i in range(n)]

def grid_split_by_size(img, size, flattern=False):
    hor_sizes = n_split(img.width, max(img.width//size, 1))
    ver_sizes = n_split(img.height, max(img.height//size, 1))
    iii = []
    y = 0

    for ver_size in ver_sizes:
        ii = []
        x = 0
        for hor_size in hor_sizes:
            ii.append(img.crop((x, y, x+hor_size, y+ver_size)))
            x += hor_size
        y += ver_size
        iii.append(ii)

    if flattern:
        iii = list(itertools.chain.from_iterable(iii))
    return iii


def grid_split(img, size, overwrap=True, flattern=False):
    if overwrap:
        return grid_split_with_overwrap(img, size, flattern)
    return grid_split_by_size(img, size, flattern)


def yes_no_input(prompt):
    while True:
        choice = input(prompt + ' [Y/n]:').lower()
        if choice in ['y', 'ye', 'yes']:
            return True
        if choice in ['n', 'no']:
            return False

def wrap_iter(t):
    if isinstance(t, (tuple, list)):
        return t
    return (t, )

def paste_center(bg, fg, overwrite=False):
    # assert bg.width >= fg.width
    # assert bg.height >= fg.height
    x = (bg.width - fg.width) // 2
    y = (bg.height - fg.height) // 2
    if not overwrite:
        bg = bg.copy()
    bg.paste(fg, (x, y))
    return bg


def pad_to_size(img, size=None, color=None):
    if size:
        if hasattr(size, '__len__'):
            assert len(size) == 2
        else:
            size = (size, size)
    else:
        long_side = max(img.size)
        size = (long_side, long_side)

    if img.width/img.height > size[0]/size[1]:
        # 横長
        scale = size[0]/img.width
    else:
        # 縦長
        scale = size[1]/img.height

    fg = img.resize((int(img.width*scale), int(img.height*scale)))
    bg = Image.new(mode=img.mode, size=size, color=color or 0)
    return paste_center(bg, fg)

def log(*args, **kwargs):
    print(*args, **kwargs)
    # logger.info(*args, **kwargs)


def load_images_from_dir_or_file(src, with_path=False, with_image=True):
    paths = []
    if os.path.isdir(src):
        paths = glob(os.path.join(src, '*.jpg')) + glob(os.path.join(src, '*.png'))
    elif os.path.isfile(src):
        paths = [src]
    if len(paths) == 0:
        raise RuntimeError(f'Invalid src: {src}')

    if with_image:
        images = [Image.open(p) for p in paths]

    if with_path:
        if with_image:
            return images, paths
        else:
            return paths
    if not with_image:
        raise RuntimeError('Either with_path or with_image should be True.')
    return images

def curry(fn, *args, **kwds):
    def callit(*moreargs, **morekwds):
        kw = kwds.copy()
        kw.update(morekwds)
        return fn(*(args+moreargs), **kw)
    return callit

def Curry(c, *args, **kwargs):
    class Curried(c):
        def __init__(self, *more_args, **more_kwargs):
            kw = kwargs.copy()
            kw.update(more_kwargs)
            super().__init__(*(args + more_args), **kw)
    return Curried

class Counter():
    def __init__(self, limit):
        self.i = 0
        self.limit = limit

    def inc(self, diff=1):
        self.i += diff
        return self.i > self.limit


def tee(s, f):
    print(f(s))
    return s

def with_wrote(s):
    print('wrote', s)
    return s

def with_log(s, fmt):
    print(fmt.format(s))
    return s


def prod(recipe):
    keys = list(recipe.keys())
    values = list(recipe.values())
    p = [dict(zip(keys, vv)) for vv in itertools.product(*values)]
    return p

def prod_fmt(fmt, recipe):
    pp = prod(recipe)
    return [fmt.format(**p) for p in pp]
