import os
import numpy as np
from glob import glob
import itertools
import resource



def yes_no_input(prompt):
    while True:
        choice = input(prompt + ' [Y/n]:').lower()
        if choice in ['y', 'ye', 'yes']:
            return True
        if choice in ['n', 'no']:
            return False

def wrap_iter(t):
    if isinstance(t, (tuple, list)):
        return t
    return (t, )

def log(*args, **kwargs):
    print(*args, **kwargs)
    # logger.info(*args, **kwargs)

def center_crop(image, size):
    if isinstance(size, (int, float)):
        size = [size, size]

    return image.crop((
        (image.width - size[0]) // 2,
        (image.height - size[1]) // 2,
        size[0],
        size[1],
    ))


def curry(fn, *args, **kwds):
    def callit(*moreargs, **morekwds):
        kw = kwds.copy()
        kw.update(morekwds)
        return fn(*(args+moreargs), **kw)
    return callit

def Curry(c, *args, **kwargs):
    class Curried(c):
        def __init__(self, *more_args, **more_kwargs):
            kw = kwargs.copy()
            kw.update(more_kwargs)
            super().__init__(*(args + more_args), **kw)
    return Curried

class Counter():
    def __init__(self, limit):
        self.i = 0
        self.limit = limit

    def inc(self, diff=1):
        self.i += diff
        return self.i > self.limit


def tee(s, f):
    print(f(s))
    return s

def with_wrote(s):
    print('wrote', s)
    return s

def with_mkdir(*args):
    d = os.path.join(*args)
    os.makedirs(d, exist_ok=True)
    return d

def with_log(s, fmt):
    print(fmt.format(s))
    return s


def prod(recipe):
    keys = list(recipe.keys())
    values = list(recipe.values())
    p = [dict(zip(keys, vv)) for vv in itertools.product(*values)]
    return p

def prod_fmt(fmt, recipe):
    pp = prod(recipe)
    return [fmt.format(**p) for p in pp]

def set_file_descriptor_limit(new_limit):
    soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
    # print(f"Current soft limit: {soft}, Current hard limit: {hard}")
    new_soft_limit = min(new_limit, hard)
    resource.setrlimit(resource.RLIMIT_NOFILE, (new_soft_limit, hard))
