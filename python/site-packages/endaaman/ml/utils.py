import random
import math

import cv2
import torch
import numpy as np
from torch import optim
from torchvision import transforms
from sklearn import metrics as skmetrics


__all__ = [
    'get_global_seed',
    'fix_global_seed',
    'smart_cat',
    'pil_to_tensor',
    'tensor_to_pil',
    'get_random_states',
    'restore_random_states',
    'overlay_heatmap',
    'roc_auc_ci',
]


__GLOBAL_SEED = 42

def get_global_seed():
    return __GLOBAL_SEED

def fix_global_seed(seed):
    global __GLOBAL_SEED
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.random.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.use_deterministic_algorithms = True
    __GLOBAL_SEED = seed


def smart_cat(tt):
    # list of tensor
    if all(isinstance(t, torch.Tensor) for t in tt):
        return torch.cat(tt)

    # list or tuple of list or tuple tensor
    if all(isinstance(t, (tuple, list)) for t in tt):
        return tuple(map(smart_cat, zip(*tt)))

    if all(isinstance(t, dict) for t in tt):
        if not all(tt[0].keys() == t.keys() for t in tt):
            raise RuntimeError('Dict keys are not all same.')
        keys = tt[0].keys()
        values = smart_cat([list(t.values()) for t in tt])
        return dict(zip(keys, values))

    if all(t is None for t in tt):
        return None

    raise RuntimeError('Invalid value:', tt)

def pil_to_tensor(img):
    return transforms.functional.to_tensor(img)

def tensor_to_pil(tensor):
    a = tensor.min()
    b = tensor.max()
    img = (tensor - a) / (b - a)
    return transforms.functional.to_pil_image(img)

def calc_mean_and_std(images, dim=()):
    mean = None
    std = None
    to_tensor = transforms.ToTensor()
    for img in images:
        x = to_tensor(img)
        m, s = x.mean(dim=dim), x.std(dim=dim)
        mean = m if isinstance(m, type(None)) else mean + m
        std = s if isinstance(s, type(None)) else std + s
    mean /= len(images)
    std /= len(images)
    return mean, std

def get_random_states():
    b = {
        'random': random.getstate(),
        'np_random': np.random.get_state(),
        'torch': torch.get_rng_state(),
        'torch_random': torch.random.get_rng_state(),
    }
    if torch.cuda.is_available():
        b.update({
            'cuda_random': torch.cuda.get_rng_state(),
            'cuda_random_all': torch.cuda.get_rng_state_all(),
        })
    return b

def restore_random_states(checkpoint):
    random.setstate(checkpoint['random'])
    np.random.set_state(checkpoint['np_random'])
    torch.set_rng_state(checkpoint['torch'])
    torch.random.set_rng_state(checkpoint['torch_random'])
    if torch.cuda.is_available():
        torch.cuda.set_rng_state(checkpoint['cuda_random'])
        torch.cuda.set_rng_state_all(checkpoint['cuda_random_all'])


def get_state_dict(model):
    if isinstance(model, torch.nn.DataParallel):
        return model.module.state_dict()
    return model.state_dict()


def overlay_heatmap(mask: torch.Tensor, img: torch.Tensor, alpha=1.0, threshold=0.2, cmap=cv2.COLORMAP_JET):
    """Make heatmap from mask and synthesize GradCAM result image using heatmap and img.
    Args:
        mask (torch.tensor): mask shape of (1, H, W) and each element has value in range [0, 1]
    Return:
        heatmap (torch.tensor): heatmap img shape of (3, H, W)
    """
    mask = mask.squeeze().cpu()
    img = img.squeeze().cpu()
    mask_mask = (mask > threshold) * alpha
    heatmap = (255 * mask).type(torch.uint8).numpy()
    heatmap = cv2.applyColorMap(heatmap, cmap)
    heatmap = torch.from_numpy(heatmap).permute(2, 0, 1).float().div(255)
    # BGR -> RGB
    heatmap = heatmap[[2, 1, 0], :, :]

    masked = img*(-mask_mask+1) + heatmap*mask_mask
    # masked = masked.clamp(max=1.0)
    return heatmap, masked


def roc_auc_ci(y_true, y_score, positive=1):
    AUC = skmetrics.roc_auc_score(y_true, y_score)
    N1 = sum(y_true == positive)
    N2 = sum(y_true != positive)
    Q1 = AUC / (2 - AUC)
    Q2 = 2*AUC**2 / (1 + AUC)
    SE_AUC = math.sqrt((AUC*(1 - AUC) + (N1 - 1)*(Q1 - AUC**2) + (N2 - 1)*(Q2 - AUC**2)) / (N1*N2))
    lower = AUC - 1.96*SE_AUC
    upper = AUC + 1.96*SE_AUC
    if lower < 0:
        lower = 0
    if upper > 1:
        upper = 1
    return (lower, upper)

if __name__ == '__main__':

    x0 = {
        'a': torch.tensor([1,2,3]),
        'b': torch.tensor([4,5,6]),
    }

    x1 = {
        'a': torch.tensor([1,2]),
        'b': torch.tensor([4,5]),
    }

    print(smart_cat([x0, x1]))


def hover_images_on_scatters(scatters, imagess, ax=None, ):
    if ax is None:
        ax = plt.gca()
    fig = ax.figure
    imagebox = OffsetImage(imagess[0][0], zoom=.5)
    imagebox.image.axes = ax
    annot = AnnotationBbox(
            imagebox,
            xy=(0, 0),
            # xybox=(256, 256),
            # xycoords='data',
            boxcoords='offset points',
            # boxcoords=('axes fraction', 'data'),
            pad=0.1,
            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=-0.3'))
    annot.set_visible(False)
    ax.add_artist(annot)

    def hover(event):
        vis = annot.get_visible()
        if event.inaxes != ax:
            return
        for n, (sc, ii) in enumerate(zip(scatters, imagess)):
            cont, index = sc.contains(event)
            if cont:
                i = index['ind'][0]
                pos = sc.get_offsets()[i]
                annot.xy = pos
                annot.xybox = pos + np.array([150, 30])
                image = ii[i]
                # text = unique_code[n]
                # annot.set_text(text)
                # annot.get_bbox_patch().set_facecolor(cmap(int(text)/10))
                imagebox.set_data(image)
                annot.set_visible(True)
                fig.canvas.draw_idle()
                return

        if vis:
            annot.set_visible(False)
            fig.canvas.draw_idle()
            return

    fig.canvas.mpl_connect('motion_notify_event', hover)
