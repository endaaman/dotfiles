import torch
import numpy as np
from sklearn import metrics as skmetrics

from .functional import multi_accuracy


class BaseMetrics:
    def __init__(self, format='{:.3f}', threshold=0.5, selector=None):
        self.format = format
        self.selector = selector or (lambda *aa: [*aa])

    def __call__(self, preds, gts, batch=True):
        preds, gts = self.selector(preds, gts)
        vv = self.calc(preds, gts, batch)
        if vv is None:
            return None
        if not isinstance(vv, (tuple, list)):
            vv = (vv, )
        values = []
        for v in vv:
            if torch.is_tensor(v):
                if len(v.shape) > 0:
                    raise RuntimeError('Value should be single:', v)
                v = v.item()
            values.append(v)
        return values

    def calc(self, preds, gts, batch=True):
        raise RuntimeError('Not implemented')


class ROCMetrics(BaseMetrics):
    def __init__(self, keys, **kwargs):
        super().__init__(**kwargs)
        K = ['auc', 'acc', 'recall', 'specificity']
        assert all(k in K for k in keys) and len(keys) > 0
        self.keys = keys

    def calc(self, preds, gts, batch=True):
        if batch:
            return None
        preds = preds.detach().cpu().numpy()
        gts = gts.detach().cpu().numpy()
        fpr, tpr, thresholds = skmetrics.roc_curve(gts, preds)
        auc = skmetrics.auc(fpr, tpr)
        youden_index = np.argmax(tpr - fpr)
        preds_bool = preds > thresholds[youden_index]
        acc = skmetrics.accuracy_score(preds_bool, gts)
        m = {
            'auc': auc,
            'acc': acc,
            'recall': tpr[youden_index],
            'specificity': -fpr[youden_index]+1,
        }
        return [m[k] for k in self.keys]

class BinaryAUC(BaseMetrics):
    def calc(self, preds, gts, batch=True):
        pred_y = preds.flatten().numpy()
        gts_y = gts.flatten().numpy()
        return skmetrics.roc_auc_score(gts_y, pred_y)

class MultiAccuracy(BaseMetrics):
    def __init__(self, by_index=True, **kwargs):
        super().__init__(**kwargs)
        self.by_index = by_index

    def calc(self, preds, gts, batch=True):
        return multi_accuracy(preds, gts, self.by_index)

class MultiMacroAccuracy(BaseMetrics):
    def __init__(self, by_index=True, **kwargs):
        super().__init__(**kwargs)
        self.by_index = by_index

    def calc(self, preds, gts, batch=True):
        pass

class AccuracyByChannel(BaseMetrics):
    def __init__(self, target_channel, by_index=True, **kwargs):
        super().__init__(**kwargs)
        self.target_channel = target_channel
        self.by_index = by_index

    def calc(self, preds, gts, batch=True):
        target_idx = gts == self.target_channel
        preds = preds[target_idx]
        gts = gts[target_idx]
        if len(gts) == 0:
            return 0.0
        preds_label = np.argmax(preds, axis=1)
        if self.by_index:
            gts_label = gts
        else:
            gts_label = torch.argmax(gts, axis=1)
        correct = torch.sum(gts_label == preds_label)

        return correct / len(gts_label)




class ThresholdMetrics:
    def __init__(self, threshold=0.5, **kwargs):
        self.threshold = threshold

class BinaryAccuracy(ThresholdMetrics):
    def calc(self, preds, gts, batch=True):
        pred_y = preds.flatten() > self.threshold
        gts_y = gts.flatten() > self.threshold
        correct = torch.sum(gts_y == pred_y)
        return correct / len(gts_y)

class BinaryRecall(ThresholdMetrics):
    def calc(self, preds, gts, batch=True):
        pred_y = preds.flatten() > self.threshold
        gts_y = gts.flatten() > self.threshold
        pos_gts_y = gts_y(gts_y > 0)
        if len(pos_gts_y) == 0:
            return -0.0
        return torch.sum(pred_y[gts_y > 0] == pos_gts_y) / len(pos_gts_y)

class BinarySpecificity(ThresholdMetrics):
    def calc(self, preds, gts, batch=True):
        pred_y = preds.flatten() > self.threshold
        gts_y = gts.flatten() > self.threshold
        neg_gts_y = gts_y[gts_y < 1]
        if len(neg_gts_y) == 0:
            return -0.0
        return torch.sum(pred_y[gts_y < 1] == neg_gts_y) / len(neg_gts_y)
