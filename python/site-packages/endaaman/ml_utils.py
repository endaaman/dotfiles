import random
import math

import cv2
import torch
import numpy as np
from torch import optim
from torchvision import transforms
from sklearn import metrics as skmetrics


__GLOBAL_SEED = 42

def get_global_seed():
    return __GLOBAL_SEED

def fix_global_seed(seed):
    global __GLOBAL_SEED
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.random.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.use_deterministic_algorithms = True
    __GLOBAL_SEED = seed


def smart_cat(tt):
    # list of tensor
    if all(isinstance(t, torch.Tensor) for t in tt):
        return torch.cat(tt)

    # list or tuple of list or tuple tensor
    if all(isinstance(t, (tuple, list)) for t in tt):
        return tuple(map(smart_cat, zip(*tt)))

    return RuntimeError('Invalid value:', tt)

def pil_to_tensor(img):
    return transforms.functional.to_tensor(img)

def tensor_to_pil(tensor):
    a = tensor.min()
    b = tensor.max()
    img = (tensor - a) / (b - a)
    return transforms.functional.to_pil_image(img)

def calc_mean_and_std(images, dim=()):
    mean = None
    std = None
    to_tensor = transforms.ToTensor()
    for img in images:
        x = to_tensor(img)
        m, s = x.mean(dim=dim), x.std(dim=dim)
        mean = m if isinstance(m, type(None)) else mean + m
        std = s if isinstance(s, type(None)) else std + s
    mean /= len(images)
    std /= len(images)
    return mean, std

def get_random_states():
    b = {
        'random': random.getstate(),
        'np_random': np.random.get_state(),
        'torch': torch.get_rng_state(),
        'torch_random': torch.random.get_rng_state(),
    }
    if torch.cuda.is_available():
        b.update({
            'cuda_random': torch.cuda.get_rng_state(),
            'cuda_random_all': torch.cuda.get_rng_state_all(),
        })
    return b

def restore_random_states(checkpoint):
    random.setstate(checkpoint['random'])
    np.random.set_state(checkpoint['np_random'])
    torch.set_rng_state(checkpoint['torch'])
    torch.random.set_rng_state(checkpoint['torch_random'])
    if torch.cuda.is_available():
        torch.cuda.set_rng_state(checkpoint['cuda_random'])
        torch.cuda.set_rng_state_all(checkpoint['cuda_random_all'])


def get_state_dict(model):
    if isinstance(model, torch.nn.DataParallel):
        return model.module.state_dict()
    return model.state_dict()


def overlay_heatmap(mask: torch.Tensor, img: torch.Tensor, alpha=1.0, threshold=0.2, cmap=cv2.COLORMAP_JET):
    """Make heatmap from mask and synthesize GradCAM result image using heatmap and img.
    Args:
        mask (torch.tensor): mask shape of (1, H, W) and each element has value in range [0, 1]
    Return:
        heatmap (torch.tensor): heatmap img shape of (3, H, W)
    """
    mask = mask.squeeze().cpu()
    img = img.squeeze().cpu()
    mask_mask = (mask > threshold) * alpha
    heatmap = (255 * mask).type(torch.uint8).numpy()
    heatmap = cv2.applyColorMap(heatmap, cmap)
    heatmap = torch.from_numpy(heatmap).permute(2, 0, 1).float().div(255)
    # BGR -> RGB
    heatmap = heatmap[[2, 1, 0], :, :]

    masked = img*(-mask_mask+1) + heatmap*mask_mask
    # masked = masked.clamp(max=1.0)
    return heatmap, masked


def roc_auc_ci(y_true, y_score, positive=1):
    AUC = skmetrics.roc_auc_score(y_true, y_score)
    N1 = sum(y_true == positive)
    N2 = sum(y_true != positive)
    Q1 = AUC / (2 - AUC)
    Q2 = 2*AUC**2 / (1 + AUC)
    SE_AUC = math.sqrt((AUC*(1 - AUC) + (N1 - 1)*(Q1 - AUC**2) + (N2 - 1)*(Q2 - AUC**2)) / (N1*N2))
    lower = AUC - 1.96*SE_AUC
    upper = AUC + 1.96*SE_AUC
    if lower < 0:
        lower = 0
    if upper > 1:
        upper = 1
    return (lower, upper)
