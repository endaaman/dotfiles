import sys
import re
from string import capwords
import inspect
import asyncio
from typing import Callable, Type
import argparse

from pydantic import BaseModel, Field


def snake_to_pascal(s):
    r = capwords(s.replace('_',' '))
    r = r.replace(' ','')
    return r

def snake_to_kebab(s):
    return s.replace('_','-')


def field(default_value, long_arg, short_arg=None):
    if short_arg:
        cli = (long_arg, short_arg)
    else:
        cli = (long_arg, )
    return Field(default_value, cli=cli)

primitive2type = {
    'string': str,
    'number': float,
    'integer': int,
}

VERBOSE = False

def register_cls_to_parser(cls, parser):
    if VERBOSE:
        print(cls)
    for key, prop in cls.schema()['properties'].items():
        if VERBOSE:
            print('Name: ', key)
            print('Prop:', prop)

        snake_key = key.replace('_', '-')
        if 'l' in prop:
            snake_key = prop['l']

        args = [f'--{snake_key}']
        if 's' in prop:
            args.append(prop['s'])

        kwargs = {}
        if 'description' in prop:
            kwargs['help'] = prop['description']

        if prop['type'] in primitive2type:
            kwargs['type'] = primitive2type[prop['type']]
            if 'default' in prop:
                kwargs['default'] = prop['default']
                kwargs['metavar'] = str(prop['default'])
            else:
                kwargs['required'] = True
                kwargs['metavar'] = None
        elif prop['type'] == 'boolean':
            # if 'default' in prop:
            #     print('default value of bool is ignored.')
            kwargs['action'] = 'store_true'
        elif prop['type'] == 'array':
            if 'default' in prop:
                kwargs['default'] = prop['default']
                kwargs['metavar'] = str(prop['default'])
                kwargs['nargs'] = '+'
            else:
                kwargs['required'] = True
                kwargs['metavar'] = None
                kwargs['nargs'] = '*'
            kwargs['type'] = primitive2type[prop['items']['type']]

        if 'choices' in prop:
            kwargs['choices'] = prop['choices']

        if VERBOSE:
            print('args', args)
            print('kwargs', kwargs)
            print()

        parser.add_argument(*args, **kwargs)


class BaseCLI:
    class CommonArgs(BaseModel):
        pass

    def _pre_common(self, a):
        pre_common = getattr(self, 'pre_common', None)
        if pre_common:
            pre_common(a)

    def wrap_runner(self, key):
        runner = getattr(self, key)
        def alt_runner(args):
            self.a = args
            self.function = key
            self._pre_common(args)
            print(f'Starting <{key}>')
            d = args.dict()
            if len(d) > 0:
                print('Args')
                maxlen = max(len(k) for k in d) if len(d) > 0 else -1
                for k, v in d.items():
                    print(f'\t{k:<{maxlen+1}}: {v}')
            else:
                print('No args')

            if inspect.iscoroutinefunction(runner):
                r = asyncio.run(runner(args))
            else:
                r =  runner(args)
            print(f'Done <{key}>')
            return r
        return alt_runner

    def __init__(self):
        self.a = None
        self.runners = {}
        self.function = None
        self.default_args_class = getattr(self.__class__, 'CommonArgs', self.CommonArgs)

        self.main_parser = argparse.ArgumentParser(add_help=False)
        sub_parsers = self.main_parser.add_subparsers()
        for key in dir(self):
            m = re.match(r'^run_(.*)$', key)
            if not m:
                continue
            name = m[1]

            subcommand_name = snake_to_kebab(name)
            args_class_name = snake_to_pascal(name) + 'Args'

            sub_parser = sub_parsers.add_parser(subcommand_name, parents=[self.main_parser])
            args_class = getattr(self, args_class_name, self.default_args_class)
            register_cls_to_parser(args_class, sub_parser)
            sub_parser.set_defaults(__function=name, __cls=args_class)

    def run(self):
        self.raw_args = self.main_parser.parse_args()
        if not hasattr(self.raw_args, '__function'):
            self.main_parser.print_help()
            exit(0)

        argdict = {
            k:v  for k, v in self.raw_args.__dict__.items() if not k.startswith('__')
        }
        instance = self.raw_args.__dict__['__cls'].parse_obj(argdict)
        name = self.raw_args.__dict__['__function']
        function = getattr(self, 'run_' + name)

        self.a = instance

        self._pre_common(instance)
        print(f'Starting <{name}>')
        if len(argdict) > 0:
            print('Args')
            maxlen = max(len(k) for k in argdict) if len(argdict) > 0 else -1
            for k, v in argdict.items():
                print(f'\t{k:<{maxlen+1}}: {v}')
        else:
            print('No args')

        if inspect.iscoroutinefunction(function):
            r = asyncio.run(function(instance))
        else:
            r =  function(instance)
        print(f'Done <{name}>')

        # cls.parse_obj(parser.parse_args().__dict__)


class CLI(BaseCLI):
    class FooArgs(BaseCLI.CommonArgs):
        bar = 123
        upsample: bool
        noaug: bool
        epoch: int = Field(100, s='-E')
        ss: list[str]
        ii: list[int] = [123]
        foo_bar: int

    def run_foo(self, a):
        print(a)
        print(a.bar)

    async def run_async(self, a):
        await asyncio.sleep(1)
        print('hi')
        await asyncio.sleep(1)
        print('hi')
        await asyncio.sleep(1)
        print('hi')
        print('async')

if __name__ == '__main__':
    cli = CLI()
    cli.run()
