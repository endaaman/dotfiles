import os
import json

import numpy as np
import torch
from PIL import Image
from matplotlib import pyplot as plt
from torchvision import transforms
from torchvision.io import read_image
from torchvision.models import get_model, get_model_weights
import timm
import torchsummary
from pydantic import Field
import pytorch_grad_cam as CAM
from pytorch_grad_cam.utils.image import show_cam_on_image
from pytorch_grad_cam.utils.model_targets import BinaryClassifierOutputTarget, ClassifierOutputTarget

from endaaman import with_wrote
from endaaman.ml import BaseMLCLI, BaseMLArgs


LABELS = json.load(open('./datasets/ImageNet/labels.json', encoding='utf-8'))


# for swin
def reshape_transform(tensor, height=8, width=8):
    print(tensor.shape)
    result = tensor.reshape(tensor.size(0), height, width, tensor.size(2))
    result = result.transpose(2, 3).transpose(1, 2)
    return result


class CLI(BaseMLCLI):
    class PredArgs(BaseMLArgs):
        model:str = Field('resnetrs50', cli=('--model', '-m'))
        src:str = Field(..., cli=('--src', '-s'))
        size:int = 512

    def run_pred(self, a:PredArgs):
        model = timm.create_model(a.model, pretrained=True)

        size = a.size
        image = Image.open(a.src)
        image = image.convert('RGB').resize((size, size))

        device = 'cuda' if torch.cuda.is_available() else 'cpu'

        preprocess = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((size, size), antialias=True),
            # transforms.CenterCrop((size, size)),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        # preprocess = weights.transforms()
        batch = preprocess(image)[None, ...]

        batch = batch.to(device)
        model.to(device).eval()
        with torch.set_grad_enabled(False):
            prediction = model(batch).squeeze(0).softmax(0)
        class_id = prediction.argmax().item()
        print(LABELS[class_id], class_id)
        # torchsummary.summary(model, input_size=(3, size, size))

    class CamArgs(BaseMLArgs):
        model:str = Field('resnetrs50', cli=('--model', '-m'))
        src:str = Field(..., cli=('--src', '-s'))
        size:int = 512
        id:int = -1

    def run_cam(self, a:CamArgs):
        # weights = get_model_weights(name).DEFAULT
        # model = get_model(name, weights=weights)

        # timm
        model = timm.create_model(a.model, pretrained=True)

        size = a.size
        image = Image.open(a.src)
        image = image.convert('RGB').resize((size, size))

        device = 'cuda' if torch.cuda.is_available() else 'cpu'

        preprocess = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((size, size), antialias=True),
            # transforms.CenterCrop((size, size)),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        # preprocess = weights.transforms()
        batch = preprocess(image)[None, ...]


        batch = batch.to(device)
        model.to(device).eval()
        with torch.set_grad_enabled(False):
            prediction = model(batch).squeeze(0).softmax(0)
        class_id = prediction.argmax().item()
        print(LABELS[class_id], class_id)
        # torchsummary.summary(model, input_size=(3, size, size))


        gradcam = CAM.GradCAM(
            model=model,
            # vit
            # target_layers=[model.blocks[-1].ls2], # vit
            # reshape_transform=reshape_transform,

            # resnetv2
            # target_layers=[model.stages[-1].blocks[-1].conv3],

            # effnet
            # target_layers=[model.conv_head],

            # RS
            target_layers=[model.layer4[-1].act3],
            use_cuda=device=='cuda')

        # notebook computer 681
        # Pomeranian 259
        # shepherd 235
        # tiger cat 282
        cam_class_id = a.id if a.id > 0 else class_id
        targets = [ClassifierOutputTarget(cam_class_id)]
        mask = gradcam(input_tensor=batch, targets=targets)[0]
        visualization = show_cam_on_image(np.array(image)/255, mask, use_rgb=True)
        plt.imshow(visualization)
        f = os.path.splitext(os.path.basename(a.src))[0]
        plt.savefig(with_wrote(f'out/{f}_{cam_class_id}.jpg'))
        plt.show()

if __name__ == '__main__':
    cli = CLI()
    cli.run()
