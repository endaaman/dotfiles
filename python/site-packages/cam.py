import os
import re
import json

import numpy as np
import torch
from PIL import Image
from matplotlib import pyplot as plt
from torchvision import transforms
from torchvision.io import read_image
from torchvision.models import get_model, get_model_weights
import timm
import torchsummary
from pydantic import Field
import pytorch_grad_cam as CAM
from pytorch_grad_cam.utils.image import show_cam_on_image
from pytorch_grad_cam.utils.model_targets import BinaryClassifierOutputTarget, ClassifierOutputTarget

from endaaman import with_wrote
from endaaman.ml.cli2 import BaseMLCLI, BaseMLArgs


LABELS = json.load(open('./datasets/ImageNet/labels.json', encoding='utf-8'))


# for swin
def reshape_transform(tensor, height=8, width=8):
    print(tensor.shape)
    result = tensor.reshape(tensor.size(0), height, width, tensor.size(2))
    result = result.transpose(2, 3).transpose(1, 2)
    return result


def get_cam_layers(m, name=None):
    name = name or m.default_cfg['architecture']
    if re.match(r'.*efficientnet.*', name):
        return [m.conv_head]
    if re.match(r'^resnetrs.*', name):
        return [m.layer4[-1]]
    if re.match(r'^resnetv2.*', name):
        return [m.stages[-1].blocks[-1].conv3]
    if re.match(r'^resnet\d+', name):
        return [m.layer4[-1].act2]
    if re.match(r'^caformer_.*', name):
        return [m.stages[-1].blocks[-1].norm1]
    if name == 'swin_base_patch4_window7_224':
        return [m.layers[-1].blocks[-1].norm1]
    raise RuntimeError('CAM layers are not determined.')
    return []

class CLI(BaseMLCLI):
    class PredArgs(BaseMLArgs):
        model:str = Field('resnetrs50', s='-m')
        src:str = Field(..., s='-s')
        size:int = 512

    def run_pred(self, a:PredArgs):
        model = timm.create_model(a.model, pretrained=True)

        size = a.size
        image = Image.open(a.src)
        image = image.convert('RGB').resize((size, size))

        device = 'cuda' if torch.cuda.is_available() else 'cpu'

        preprocess = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((size, size), antialias=True),
            # transforms.CenterCrop((size, size)),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        # preprocess = weights.transforms()
        batch = preprocess(image)[None, ...]

        batch = batch.to(device)
        model.to(device).eval()
        with torch.set_grad_enabled(False):
            prediction = model(batch).squeeze(0).softmax(0)
        class_id = prediction.argmax().item()
        print(LABELS[class_id], class_id)
        # torchsummary.summary(model, input_size=(3, size, size))

    class CamArgs(BaseMLArgs):
        model:str = Field('resnetrs50', s='-m')
        src:str = Field(..., s='-s')
        size:int = 512
        id:int = -1

    def run_cam(self, a:CamArgs):
        # weights = get_model_weights(name).DEFAULT
        # model = get_model(name, weights=weights)

        # timm
        model = timm.create_model(a.model, pretrained=True)

        size = a.size
        image = Image.open(a.src)
        image = image.convert('RGB').resize((size, size))

        device = 'cuda' if torch.cuda.is_available() else 'cpu'

        preprocess = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((size, size), antialias=True),
            # transforms.CenterCrop((size, size)),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        # preprocess = weights.transforms()
        batch = preprocess(image)[None, ...]

        batch = batch.to(device)
        model.to(device).eval()
        with torch.set_grad_enabled(False):
            prediction = model(batch).squeeze(0).softmax(0)
        class_id = prediction.argmax().item()
        print(LABELS[class_id], class_id)
        # torchsummary.summary(model, input_size=(3, size, size))

        def reshape_transform(tensor, height=7, width=7):
            print(tensor.shape)
            # raise NotImplemented()
            result = tensor.reshape(tensor.size(0), height, width, tensor.size(-1))

            # Bring the channels to the first dimension,
            # like in CNNs.
            result = result.transpose(2, 3).transpose(1, 2)
            print(result.shape)
            return result

        # gradcam = CAM.GradCAM(
        gradcam = CAM.GradCAMPlusPlus(
            model=model,
            # vit
            # target_layers=[model.blocks[-1].ls2], # vit
            # reshape_transform=reshape_transform,

            # target_layers=get_cam_layers(model, name=a.model),
            # reshape_transform=reshape_transform,
        )

        # notebook computer 681
        # Pomeranian 259
        # shepherd 235
        # tiger cat 282
        cam_class_id = a.id if a.id > 0 else class_id
        targets = [ClassifierOutputTarget(cam_class_id)]
        mask = gradcam(input_tensor=batch, targets=targets)[0]
        visualization = show_cam_on_image(np.array(image)/255, mask, use_rgb=True)
        plt.imshow(visualization)
        f = os.path.splitext(os.path.basename(a.src))[0]
        plt.savefig(with_wrote(f'out/{f}_{cam_class_id}.jpg'))
        plt.show()

if __name__ == '__main__':
    cli = CLI()
    cli.run()
