import os
import re
import json

import numpy as np
import torch
from PIL import Image
from matplotlib import pyplot as plt
from torchvision import transforms
from torchvision.io import read_image
from torchvision.models import get_model, get_model_weights
import timm
import torchsummary
from pydantic import Field
import pytorch_grad_cam as CAM
from pytorch_grad_cam.utils.image import show_cam_on_image
from pytorch_grad_cam.utils.model_targets import BinaryClassifierOutputTarget, ClassifierOutputTarget

from endaaman import with_wrote
from endaaman.ml.cli import BaseMLCLI, BaseMLArgs


LABELS = json.load(open('./datasets/ImageNet/labels.json', encoding='utf-8'))


# for swin
def reshape_transform(tensor, height=8, width=8):
    print(tensor.shape)
    result = tensor.reshape(tensor.size(0), height, width, tensor.size(2))
    result = result.transpose(2, 3).transpose(1, 2)
    return result


def get_cam_layers(m, name):
    name = name or m.default_cfg['architecture']
    if re.match(r'.*efficientnet.*', name):
        return [m.conv_head]
    if re.match(r'^resnetrs.*', name):
        return [m.layer4[-1]]
    if re.match(r'^resnetv2.*', name):
        return [m.stages[-1].blocks[-1]]
    if re.match(r'^resnet\d+', name):
        return [m.layer4[-1].act2]
    if re.match(r'^caformer_.*', name):
        # return [m.stages[-1].blocks[-1].drop_path2]
        return [m.stages[-1].blocks[-1].layer_scale2]
    if re.match(r'^convnext.*', name):
        # return [m.stages[-1].blocks[-1].conv_dw]
        return [m.stages[-1].blocks[-1].norm]
    if name == 'swin_base_patch4_window7_224':
        return [m.layers[-1].blocks[-1].norm1]
    raise RuntimeError('CAM layers are not determined.')
    return []


def get_reshaper(name, width, height):
    def reshape_transform(tensor):
        result = tensor.reshape(
            tensor.size(0),
            height//32,
            width//32,
            tensor.size(-1)
        )
        result = result.transpose(2, 3).transpose(1, 2)
        # print(tensor[:, 1 :  , :].shape)
        # result = tensor[:, 1 :  , :].reshape(tensor.size(0), height, width, tensor.size(-1))
        # result = result.transpose(2, 3).transpose(1, 2)
        return result

    if re.match(r'^caformer_.*', name):
        return reshape_transform

    if re.match(r'^convnext_.*', name):
        return reshape_transform

    if name == 'swin_base_patch4_window7_224':
        return reshape_transform

    return None


class CLI(BaseMLCLI):
    class PredArgs(BaseMLArgs):
        model:str = Field('resnetrs50', s='-m')
        src:str = Field(..., s='-s')
        size:int = 512

    def run_pred(self, a:PredArgs):
        model = timm.create_model(a.model, pretrained=True)

        size = a.size
        image = Image.open(a.src)
        image = image.convert('RGB').resize((size, size))

        device = 'cuda' if torch.cuda.is_available() else 'cpu'

        preprocess = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((size, size), antialias=True),
            # transforms.CenterCrop((size, size)),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        # preprocess = weights.transforms()
        batch = preprocess(image)[None, ...]

        batch = batch.to(device)
        model.to(device).eval()
        with torch.set_grad_enabled(False):
            prediction = model(batch).squeeze(0).softmax(0)
        class_id = prediction.argmax().item()
        print(LABELS[class_id], class_id)
        # torchsummary.summary(model, input_size=(3, size, size))

    class CamArgs(BaseMLArgs):
        model:str = Field('resnetrs50', s='-m')
        src:str = Field(..., s='-s')
        size:int = -1
        id:int = -1

    def run_cam(self, a:CamArgs):
        # weights = get_model_weights(name).DEFAULT
        # model = get_model(name, weights=weights)

        # timm
        model = timm.create_model(a.model, pretrained=True)

        image = Image.open(a.src).convert('RGB')
        if a.size > 0:
            image = image.resize((a.size, a.size))

        device = 'cuda' if torch.cuda.is_available() else 'cpu'

        preprocess = transforms.Compose([
            transforms.ToTensor(),
            # transforms.Resize((size, size), antialias=True),
            # transforms.CenterCrop((size, size)),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        # preprocess = weights.transforms()
        batch = preprocess(image)[None, ...]

        batch = batch.to(device)
        model.to(device).eval()
        with torch.set_grad_enabled(False):
            prediction = model(batch).squeeze(0).softmax(0)
        class_id = prediction.argmax().item()
        print(LABELS[class_id], class_id)
        # torchsummary.summary(model, input_size=(3, size, size))

        gradcam = CAM.GradCAMPlusPlus(
            model=model,
            target_layers=get_cam_layers(model, name=a.model),
            reshape_transform=get_reshaper(name=a.model, width=image.width, height=image.height),
        )

        # notebook computer 681
        # Pomeranian 259
        # shepherd 235
        # tiger cat 282
        cam_class_id = a.id if a.id > 0 else class_id
        targets = [ClassifierOutputTarget(cam_class_id)]
        mask = gradcam(input_tensor=batch, targets=targets)[0]
        visualization = show_cam_on_image(np.array(image)/255, mask, use_rgb=True)
        plt.imshow(visualization)
        plt.show()
        f = os.path.splitext(os.path.basename(a.src))[0]

        Image.fromarray(visualization).save(with_wrote(f'out/{f}_{cam_class_id}.jpg'))

if __name__ == '__main__':
    cli = CLI()
    cli.run()
